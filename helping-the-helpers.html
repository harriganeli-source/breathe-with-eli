<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helping the Helpers | Eli Harrigan</title>
    <meta name="description" content="Breathwork and nervous system training for healthcare workers, therapists, and caregivers. Prevent burnout, stay grounded, and sustain the work you do for others.">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg">

    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Helping the Helpers | Eli Harrigan">
    <meta property="og:description" content="Breathwork and nervous system training for healthcare workers, therapists, and caregivers. Prevent burnout, stay grounded, and sustain the work you do for others.">
    <meta property="og:image" content="https://breathewitheli.com/images/team-workshop.jpg">
    <meta property="og:url" content="https://breathewitheli.com/helping-the-helpers">
    <meta name="twitter:card" content="summary_large_image">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
    <style>
        @media (max-width: 768px) {
            .two-column-grid {
                grid-template-columns: 1fr !important;
                gap: 2rem !important;
            }
        }
        /* Featured testimonial styling */
        .featured-testimonial {
            max-width: 800px;
            margin: 0 auto 3rem;
            display: flex;
            align-items: center;
            gap: 2rem;
            padding: 2rem;
            background: var(--color-white);
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.04);
        }
        .featured-testimonial {
            position: relative;
            z-index: 2;
        }
        .featured-testimonial .testimonial-photo {
            flex-shrink: 0;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            overflow: hidden;
        }
        .featured-testimonial .testimonial-photo img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        .featured-testimonial .testimonial-content p {
            font-size: 1.15rem;
            font-style: italic;
            margin-bottom: 1rem;
        }
        .featured-testimonial .testimonial-content cite {
            font-size: 1rem;
        }
        @media (max-width: 768px) {
            .featured-testimonial {
                flex-direction: column;
                text-align: center;
            }
        }
        /* Force three-column testimonials on desktop */
        .testimonials-grid {
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
        }
        /* Stack photo and text vertically in the grid */
        .testimonials-grid .testimonial-card--with-photo {
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        @media (max-width: 992px) {
            .testimonials-grid {
                grid-template-columns: 1fr;
            }
            .testimonials-grid .testimonial-card--with-photo {
                flex-direction: row;
                align-items: flex-start;
                text-align: left;
            }
        }

        /* Connected Dots Network - ABSOLUTE position on page, not fixed to viewport */
        .connected-dots {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.15;
            z-index: 1;
            overflow: visible;
        }
        /* Testimonial cards need to be above the organism */
        #testimonials .testimonial-card {
            position: relative;
            z-index: 2;
        }
        /* Override default fade-in for testimonials - slower, staggered, from bottom */
        #testimonials .testimonial-card.fade-in {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 1.2s ease, transform 1.2s ease;
        }
        #testimonials .testimonial-card.fade-in.visible {
            opacity: 1;
            transform: translateY(0);
        }
        /* Stagger delays for left-to-right animation */
        #testimonials .testimonial-card:nth-child(1).fade-in {
            transition-delay: 0s;
        }
        #testimonials .testimonial-card:nth-child(2).fade-in {
            transition-delay: 0.4s;
        }
        #testimonials .testimonial-card:nth-child(3).fade-in {
            transition-delay: 0.8s;
        }
        .connected-dots .dot {
            /* Dynamic hue set by JS - base sage green (100) shifts based on position */
            fill: hsl(var(--dot-hue, 100), 45%, 38%);
            transition: fill 0.3s ease;
        }
        .connected-dots .line {
            /* Lines use gradient between connected dots' hues */
            stroke: hsl(var(--line-hue, 100), 45%, 38%);
            stroke-width: 1.5;
            opacity: 0.6;
            transition: stroke 0.3s ease;
        }
        .intro-section-teams {
            position: relative;
        }
        .intro-section-teams .container {
            position: relative;
            z-index: 1;
        }
        @media (max-width: 768px) {
            #connected-dots-container {
                display: none;
            }
            #connected-dots-mobile-container {
                display: none;
            }
        }
        @media (min-width: 769px) {
            #connected-dots-mobile-container {
                display: none;
            }
        }
        /* Mobile version - FIXED position in viewport */
        .connected-dots-mobile {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            pointer-events: none;
            opacity: 0.35;
            z-index: 100;
            overflow: visible;
        }
        .connected-dots-mobile .dot {
            /* Dynamic hue set by JS - base sage green (100) shifts based on position */
            fill: hsl(var(--dot-hue, 100), 45%, 38%);
            transition: fill 0.3s ease;
        }
        .connected-dots-mobile .line {
            /* Lines use gradient between connected dots' hues */
            stroke: hsl(var(--line-hue, 100), 45%, 38%);
            stroke-width: 1.2;
            opacity: 0.6;
            transition: stroke 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">Eli Harrigan</a>
            <button class="nav-toggle" aria-label="Toggle navigation">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu">
                <li><a href="about.html">About</a></li>
                <li class="nav-dropdown">
                    <a href="work-with-me.html">Work With Me</a>
                    <ul class="dropdown-menu">
                        <li><a href="work-with-me.html#breathwork">Dynamic Breathwork</a></li>
                        <li><a href="work-with-me.html#coaching">Somatic Coaching</a></li>
                        <li><a href="work-with-me.html#mens-groups">Men's Groups</a></li>
                    </ul>
                </li>
                <li><a href="upcoming.html">Groups & Workshops</a></li>
                <li><a href="helping-the-helpers.html">Helping the Helpers</a></li>
                <li><a href="contact.html">Contact</a></li>
                <li><a href="book.html" class="nav-cta">Book a Session</a></li>
            </ul>
        </div>
    </nav>

    <!-- Page Header -->
    <header class="page-header">
        <div class="container">
            <h1>Helping the Helpers</h1>
        </div>
    </header>

    <!-- Connected Dots Container - spans full page for absolute positioning (Desktop) -->
    <div id="connected-dots-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; overflow: visible;">
        <svg class="connected-dots" id="connected-dots-svg" viewBox="0 0 1000 3000" preserveAspectRatio="xMidYMin slice" style="width: 100%; height: 100%;">
            <!-- Lines and dots will be created by JavaScript -->
        </svg>
    </div>

    <!-- Connected Dots Container - Mobile version (fixed position for viewport) -->
    <div id="connected-dots-mobile-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100vh; pointer-events: none; z-index: 1; overflow: visible;">
        <svg class="connected-dots-mobile" id="connected-dots-mobile-svg" viewBox="0 0 400 600" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: 100%;">
            <!-- Lines and dots will be created by JavaScript -->
        </svg>
    </div>

    <!-- Intro + Image Section (Two Column) -->
    <section class="content-section intro-section-teams" style="position: relative; background-color: var(--color-bg);">
        <div class="container">
            <div class="two-column-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 4rem; align-items: start;">
                <!-- Image -->
                <div>
                    <img src="images/team-workshop.jpg" alt="Outdoor group workshop session" style="width: 100%; max-height: 450px; object-fit: cover; border-radius: 8px;">
                </div>
                <!-- Intro Text -->
                <div style="font-size: 0.95rem;">
                    <p>The world is changing fast, and what sets people apart is changing with it.</p>
                    <p>It's less about what you know and more about how you are. Your presence. Your steadiness. Your frequency. The ability to stay grounded when things get hard and stay connected to the people around you.</p>
                    <p>Healthcare workers, therapists, coaches, and caregivers carry more than most people realize. The weight of other people's pain. The pressure to hold it together when everything feels urgent. Through breathwork and nervous system training, your people learn to down-regulate stress in real time, recover more fully between intense periods, and stay present with each other when the pressure rises.</p>
                    <p>Team members can learn to be a resource for each other—not just in their work, but in how they regulate collectively.</p>
                    <p>And there's something that happens when people breathe together in a room. They come out of it feeling more like a team than when they walked in.</p>
                </div>
            </div>
        </div>
        <a href="#testimonials" class="scroll-indicator" aria-label="Scroll to content" style="position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); opacity: 0.5;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 32px; height: 32px;">
                <path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
            </svg>
        </a>
    </section>

    <!-- Testimonials Section -->
    <section id="testimonials" class="content-section" style="background-color: var(--color-bg-alt);">
        <div class="container">
            <!-- Featured Testimonial -->
            <div class="featured-testimonial">
                <div class="testimonial-photo">
                    <img src="images/andrea.jpg" alt="Andrea M. Garroway, Ph.D.">
                </div>
                <div class="testimonial-content">
                    <p>"Eli created a supportive environment for our team throughout the entire experience. We were able to bond, reflect about our work, and develop renewed appreciation for the value of the mind-body connection."</p>
                    <cite>— Andrea M. Garroway, Ph.D., Clinical Psychologist</cite>
                </div>
            </div>
            <!-- Other Testimonials -->
            <div class="testimonials-grid">
                <div class="testimonial-card testimonial-card--with-photo">
                    <div class="testimonial-photo">
                        <img src="images/hyjekkarol.jpg" alt="Karol Hyjek" style="object-position: center 20%;">
                    </div>
                    <div class="testimonial-content">
                        <p>"Breathwork has been a deeply impactful outlet for me. It's given me a powerful way to release emotion and reconnect with myself when life feels heavy. Through conscious breathing, I've found clarity, calm, and a sense of release that helps me stay grounded and prevents burnout."</p>
                        <cite>— Karol Hyjek, MD</cite>
                    </div>
                </div>
                <div class="testimonial-card testimonial-card--with-photo">
                    <div class="testimonial-photo">
                        <img src="images/melissa_DC.jpg" alt="Melissa O'Loughlin">
                    </div>
                    <div class="testimonial-content">
                        <p>"The concepts Eli teaches about acknowledging feelings have literally changed how I move through every single day."</p>
                        <cite>— Melissa O'Loughlin, DC, CACCP</cite>
                    </div>
                </div>
                <div class="testimonial-card testimonial-card--with-photo">
                    <div class="testimonial-photo">
                        <img src="images/testimonial-matt-rohrer.jpg" alt="Matthew L. Rohrer">
                    </div>
                    <div class="testimonial-content">
                        <p>"Doing breathwork with Eli has helped open me up and shift my relationship to my own pain, sadness, and joy."</p>
                        <cite>— Matthew L. Rohrer, LCSW, Psychotherapist</cite>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- What I Offer Section -->
    <section class="content-section">
        <div class="container" style="max-width: 900px;">
            <h2 style="text-align: center; margin-bottom: 2.5rem;">What I Offer</h2>

            <div class="benefit-item" style="margin-bottom: 2rem;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--color-primary)" stroke-width="1.5">
                    <path d="M21 12a9 9 0 1 1-9-9"/>
                    <polyline points="21 3 21 9 15 9"/>
                    <path d="M21 9l-6 6"/>
                </svg>
                <div>
                    <h3 style="margin-bottom: 0.5rem; font-size: 1.5rem;">Reset: A Single Session</h3>
                    <p style="color: var(--color-text-light); margin-bottom: 1rem;">A 2-hour guided breathwork session for your team.</p>
                    <p style="color: var(--color-text-light); margin-bottom: 1rem;">You'll move through the experience together, arriving somewhere different than where you started—more present, more open, more connected to yourselves and each other.</p>
                    <p style="color: var(--color-text-light);">Works well as a standalone workshop or an introduction before committing to deeper work.</p>
                </div>
            </div>

            <div class="benefit-item" style="margin-bottom: 2rem;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--color-primary)" stroke-width="1.5">
                    <circle cx="5" cy="12" r="2"/>
                    <circle cx="11" cy="12" r="2"/>
                    <circle cx="17" cy="12" r="2"/>
                    <circle cx="23" cy="12" r="2"/>
                    <path d="M7 12h2M13 12h2M19 12h2"/>
                </svg>
                <div>
                    <h3 style="margin-bottom: 0.5rem; font-size: 1.5rem;">Sustain: A Four-Session Series</h3>
                    <p style="color: var(--color-text-light); margin-bottom: 1rem;">Four sessions over eight weeks.</p>
                    <p style="color: var(--color-text-light); margin-bottom: 1rem;">Breathwork isn't the same twice. What surfaces in session one is different from session three. The body releases in layers, and building a real relationship with the practice takes repetition.</p>
                    <p style="color: var(--color-text-light);">Over the series, you'll develop a shared language and a felt sense of what regulation actually means—not as a concept, but as something you can return to on your own—creating lasting shifts in how you relate and work together.</p>
                </div>
            </div>

            <div class="benefit-item">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--color-primary)" stroke-width="1.5">
                    <path d="M18.178 8c5.096 0 5.096 8 0 8-5.095 0-7.133-8-12.739-8-4.873 0-4.873 8 0 8 5.606 0 7.644-8 12.74-8z"/>
                </svg>
                <div>
                    <h3 style="margin-bottom: 0.5rem; font-size: 1.5rem;">Ongoing Support</h3>
                    <p style="color: var(--color-text-light); margin-bottom: 1rem;">Monthly sessions on retainer for teams that want breathwork as part of their culture, not a one-time event.</p>
                    <p style="color: var(--color-text-light);">Teams that invest in this kind of work aren't just taking care of themselves. They're protecting the thing that actually matters: real human connection.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- CTA Section -->
    <section class="cta">
        <div class="container" style="text-align: center;">
            <h2>Interested in bringing this to your team?</h2>
            <p style="max-width: 600px; margin: 1rem auto 2rem;">Let's talk about what your team needs and how I can help.</p>
            <a href="contact.html" class="btn btn-primary">Get in Touch</a>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <a href="index.html" class="footer-logo">Eli Harrigan</a>
                    <p>Breathwork & Coaching</p>
                    <p class="footer-location">Rochester, NY & Online</p>
                </div>
                <div class="footer-nav">
                    <h4>Navigate</h4>
                    <ul>
                        <li><a href="about.html">About</a></li>
                        <li class="nav-dropdown">
                    <a href="work-with-me.html">Work With Me</a>
                    <ul class="dropdown-menu">
                        <li><a href="work-with-me.html#breathwork">Dynamic Breathwork</a></li>
                        <li><a href="work-with-me.html#coaching">Somatic Coaching</a></li>
                        <li><a href="work-with-me.html#mens-groups">Men's Groups</a></li>
                    </ul>
                </li>
                        <li><a href="upcoming.html">Groups & Workshops</a></li>
                        <li><a href="helping-the-helpers.html">Helping the Helpers</a></li>
                        <li><a href="contact.html">Contact</a></li>
                        <li><a href="book.html">Book</a></li>
                    </ul>
                </div>
                <div class="footer-connect">
                    <h4>Connect</h4>
                    <ul>
                        <li><a href="mailto:eli@breathewitheli.com">eli@breathewitheli.com</a></li>
                        <li><a href="https://instagram.com/breathewitheli" target="_blank" rel="noopener">Instagram</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 Eli Harrigan. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="js/main.js"></script>

    <!-- Connected Dots Animation - Scroll-linked floating organism that grows -->
    <script>
    (function() {
        // Only run on desktop
        if (window.innerWidth <= 768) return;

        const svg = document.getElementById('connected-dots-svg');
        if (!svg) return;

        // Configuration
        const dotRadius = 5;
        const breathCycle = 10000;
        const lineGrowDuration = 3500;  // Slower line growth
        const lineGrowDelay = 1300;     // Delay before lines start growing
        const lineStagger = 350;        // Delay between each line

        // Growth stages - organism gains complexity and coherence as it moves down
        // Starts chaotic, ends as flower of life pattern
        // Stage 0: Scattered dots that will form core
        // Stage 1: More dots appear at testimonials
        // Stage 2: Final dots complete flower of life at What I Offer

        const baseScale = 1.0;
        let currentScale = baseScale;
        const stageActivationDelay = 1500;  // Delay before new dots appear after reaching section

        // Chaos factor - decreases as user scrolls (1 = chaotic, 0 = structured)
        let chaosFactor = 1.0;
        let targetChaosFactor = 1.0;

        // Flower of Life positions (final structured form)
        // Center + 6 surrounding circles pattern
        const r = 80;  // Base radius for flower of life
        const flowerPositions = [
            // Stage 0: Core - center and inner ring (7 dots)
            { x: 0, y: 0, isCenter: true, stage: 0 },  // 0: center
            { x: 0, y: -r, stage: 0 },                  // 1: top
            { x: r * 0.866, y: -r * 0.5, stage: 0 },    // 2: top right
            { x: r * 0.866, y: r * 0.5, stage: 0 },     // 3: bottom right
            { x: 0, y: r, stage: 0 },                   // 4: bottom
            { x: -r * 0.866, y: r * 0.5, stage: 0 },    // 5: bottom left
            { x: -r * 0.866, y: -r * 0.5, stage: 0 },   // 6: top left

            // Stage 1: Outer petals (6 dots)
            { x: r * 0.866, y: -r * 1.5, stage: 1 },    // 7: top right outer
            { x: r * 1.732, y: 0, stage: 1 },           // 8: right outer
            { x: r * 0.866, y: r * 1.5, stage: 1 },     // 9: bottom right outer
            { x: -r * 0.866, y: r * 1.5, stage: 1 },    // 10: bottom left outer
            { x: -r * 1.732, y: 0, stage: 1 },          // 11: left outer
            { x: -r * 0.866, y: -r * 1.5, stage: 1 },   // 12: top left outer

            // Stage 2: Final connecting dots (3 dots to complete pattern)
            { x: 0, y: -r * 2, stage: 2 },              // 13: far top
            { x: 0, y: r * 2, stage: 2 },               // 14: far bottom
            { x: r * 1.732, y: -r, stage: 2 }           // 15: far right upper
        ];

        // Chaotic starting positions (will interpolate toward flower positions)
        const chaoticOffsets = [
            { x: 20, y: -30 },    // 0
            { x: -50, y: 40 },    // 1
            { x: 70, y: 20 },     // 2
            { x: -30, y: -60 },   // 3
            { x: 45, y: 55 },     // 4
            { x: -65, y: -15 },   // 5
            { x: 35, y: -45 },    // 6
            { x: -40, y: 70 },    // 7
            { x: 60, y: -35 },    // 8
            { x: -55, y: 25 },    // 9
            { x: 25, y: 65 },     // 10
            { x: -70, y: -50 },   // 11
            { x: 50, y: 30 },     // 12
            { x: -25, y: -70 },   // 13
            { x: 40, y: 45 },     // 14
            { x: -60, y: 10 }     // 15
        ];

        // All possible connections (flower of life pattern)
        const allConnections = [
            // Stage 0: Core connections (center to inner ring + inner ring connections)
            { from: 0, to: 1, stage: 0 }, { from: 0, to: 2, stage: 0 }, { from: 0, to: 3, stage: 0 },
            { from: 0, to: 4, stage: 0 }, { from: 0, to: 5, stage: 0 }, { from: 0, to: 6, stage: 0 },
            { from: 1, to: 2, stage: 0 }, { from: 2, to: 3, stage: 0 }, { from: 3, to: 4, stage: 0 },
            { from: 4, to: 5, stage: 0 }, { from: 5, to: 6, stage: 0 }, { from: 6, to: 1, stage: 0 },

            // Stage 1: Connect outer petals
            { from: 1, to: 7, stage: 1 }, { from: 2, to: 7, stage: 1 },
            { from: 2, to: 8, stage: 1 }, { from: 3, to: 8, stage: 1 },
            { from: 3, to: 9, stage: 1 }, { from: 4, to: 9, stage: 1 },
            { from: 4, to: 10, stage: 1 }, { from: 5, to: 10, stage: 1 },
            { from: 5, to: 11, stage: 1 }, { from: 6, to: 11, stage: 1 },
            { from: 6, to: 12, stage: 1 }, { from: 1, to: 12, stage: 1 },

            // Stage 2: Final connections
            { from: 7, to: 12, stage: 2 }, { from: 7, to: 13, stage: 2 }, { from: 12, to: 13, stage: 2 },
            { from: 1, to: 13, stage: 2 },
            { from: 9, to: 10, stage: 2 }, { from: 9, to: 14, stage: 2 }, { from: 10, to: 14, stage: 2 },
            { from: 4, to: 14, stage: 2 },
            { from: 7, to: 15, stage: 2 }, { from: 8, to: 15, stage: 2 }
        ];

        // Use flower positions as allDotPositions
        const allDotPositions = flowerPositions;

        // State
        const dots = [];
        const dotElements = [];
        const lineElements = [];
        const startTime = performance.now();
        let currentStage = 0;
        let stageChangeTime = 0;
        let animationStartTime = null;  // Track when animation actually starts

        // Organism position
        let organismX = 700;
        let organismY = 400;
        let organismRotation = 0;

        let targetX = 700;
        let targetY = 400;
        let targetRotation = 0;
        let targetScale = 1.0;

        let sections = [];
        let pageHeight = 3000;

        // Create a dot element
        function createDot(pos, index) {
            const baseHue = pos.isCenter ? 100 : 100 + (index % 7) * 15 - 45;

            const dot = {
                baseX: pos.x,
                baseY: pos.y,
                x: organismX + pos.x,
                y: organismY + pos.y,
                phase: Math.random() * Math.PI * 2,
                isCenter: pos.isCenter || false,
                baseHue: baseHue,
                currentHue: baseHue,
                stage: pos.stage,
                opacity: 0,  // Start invisible, will fade in
                targetOpacity: pos.stage === 0 ? 1 : 0,
                birthTime: null  // Will be set when animation starts
            };

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('class', 'dot');
            circle.setAttribute('r', dot.isCenter ? dotRadius * 1.3 : dotRadius);
            if (dot.isCenter) circle.style.opacity = '0.85';
            circle.setAttribute('cx', dot.x);
            circle.setAttribute('cy', dot.y);
            circle.style.setProperty('--dot-hue', baseHue);
            circle.style.opacity = '0';  // Start invisible

            return { dot, circle };
        }

        // Create a line element
        function createLine(conn, index) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('class', 'line');
            line.style.opacity = '0';

            return {
                element: line,
                from: conn.from,
                to: conn.to,
                stage: conn.stage,
                index: index,
                opacity: 0,
                targetOpacity: conn.stage === 0 ? 0.6 : 0,
                birthTime: null,  // Will be set when animation starts
                growProgress: 0
            };
        }

        // Initialize all dots and lines (all start invisible)
        allDotPositions.forEach((pos, i) => {
            const { dot, circle } = createDot(pos, i);
            dots.push(dot);
            dotElements.push(circle);
        });

        allConnections.forEach((conn, i) => {
            const lineData = createLine(conn, i);
            lineElements.push(lineData);
            svg.appendChild(lineData.element);
        });

        dotElements.forEach(el => svg.appendChild(el));

        // Activate dots and lines for a stage (with delay for stages > 0)
        function activateStage(stage, time) {
            const delay = stage === 0 ? 0 : stageActivationDelay;

            dots.forEach((dot, i) => {
                if (dot.stage === stage && dot.birthTime === null) {
                    dot.birthTime = time + delay;
                    dot.targetOpacity = 1;
                }
            });

            lineElements.forEach((line, i) => {
                if (line.stage === stage && line.birthTime === null) {
                    line.birthTime = time + delay + 800; // Additional delay after dots appear
                    line.targetOpacity = 0.6;
                }
            });
        }

        function updateSectionPositions() {
            const introSection = document.querySelector('.intro-section-teams');
            const testimonialsSection = document.getElementById('testimonials');
            const whatIOfferSection = document.querySelectorAll('.content-section')[2];

            pageHeight = document.body.scrollHeight || 3000;
            const introTop = introSection ? introSection.offsetTop : 0;
            const testimonialsTop = testimonialsSection ? testimonialsSection.offsetTop : 600;
            const whatIOfferTop = whatIOfferSection ? whatIOfferSection.offsetTop : 1200;

            const toSvgY = (pageY) => (pageY / pageHeight) * 3000;

            sections = [
                {
                    el: introSection,
                    scrollThreshold: introTop,
                    targetX: 700,
                    targetY: toSvgY(introTop + 520),
                    rotation: 0,
                    scale: 1.0,
                    stage: 0
                },
                {
                    el: testimonialsSection,
                    scrollThreshold: testimonialsTop + 150,
                    targetX: 120,
                    targetY: toSvgY(testimonialsTop + 300),
                    rotation: 45,
                    scale: 1.4,
                    stage: 1  // Add first expansion at testimonials (with delay)
                },
                {
                    el: whatIOfferSection,
                    scrollThreshold: whatIOfferTop + 150,
                    targetX: 880,
                    targetY: toSvgY(whatIOfferTop + 400),
                    rotation: 90,
                    scale: 1.6,
                    stage: 2  // Add second expansion at What I Offer
                }
            ];

            if (sections[0]) {
                targetX = sections[0].targetX;
                targetY = sections[0].targetY;
                targetScale = sections[0].scale || 1.0;
                organismX = targetX;
                organismY = targetY;
                currentScale = targetScale;
            }

            const container = document.getElementById('connected-dots-container');
            if (container) {
                container.style.height = pageHeight + 'px';
            }
        }

        let currentSectionIndex = 0;
        let lastSectionChangeTime = 0;
        const sectionChangeCooldown = 1500;  // Reduced cooldown for more responsive movement
        const initialAnimationDelay = 1500;  // Delay before animation starts

        function handleScroll() {
            const scrollY = window.scrollY;
            const viewportMiddle = scrollY + window.innerHeight * 0.4;
            const now = performance.now();

            // Calculate scroll progress (0 = top, 1 = bottom)
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            const scrollProgress = Math.min(1, Math.max(0, scrollY / maxScroll));

            // Update chaos factor based on scroll (1 at top, 0 at bottom)
            targetChaosFactor = Math.max(0, 1 - scrollProgress * 1.5);

            let newSectionIndex = 0;
            for (let i = sections.length - 1; i >= 0; i--) {
                const section = sections[i];
                if (!section.el) continue;
                if (viewportMiddle >= section.scrollThreshold) {
                    newSectionIndex = i;
                    break;
                }
            }

            // More responsive - immediately update target position
            const section = sections[newSectionIndex];
            if (section) {
                targetX = section.targetX;
                targetY = section.targetY;
                targetRotation = section.rotation;
                targetScale = section.scale || 1.0;
            }

            // Stage activation still has cooldown to prevent rapid switching
            if (newSectionIndex !== currentSectionIndex &&
                (now - lastSectionChangeTime) > sectionChangeCooldown) {
                currentSectionIndex = newSectionIndex;
                lastSectionChangeTime = now;

                // Activate new stage if moving forward
                if (section && section.stage > currentStage) {
                    for (let s = currentStage + 1; s <= section.stage; s++) {
                        activateStage(s, now);
                    }
                    currentStage = section.stage;
                    stageChangeTime = now;
                }
            }
        }

        window.addEventListener('scroll', handleScroll, { passive: true });
        window.addEventListener('resize', updateSectionPositions);
        setTimeout(updateSectionPositions, 100);

        let continuousRotation = 0;

        function animate(time) {
            // Initialize animation start time on first frame
            if (animationStartTime === null) {
                animationStartTime = time;
            }

            const elapsed = time - animationStartTime;

            // Wait for initial delay before activating stage 0
            if (elapsed > initialAnimationDelay && currentStage === 0 && dots[0].birthTime === null) {
                activateStage(0, time);
            }

            // More responsive movement (increased from 0.005)
            const lerpSpeed = 0.008;
            organismX += (targetX - organismX) * lerpSpeed;
            organismY += (targetY - organismY) * lerpSpeed;
            organismRotation += (targetRotation - organismRotation) * lerpSpeed;
            currentScale += (targetScale - currentScale) * lerpSpeed;

            // Smoothly interpolate chaos factor
            chaosFactor += (targetChaosFactor - chaosFactor) * 0.02;

            continuousRotation += 0.015;

            const breathPhase = (time % breathCycle) / breathCycle;
            const breathFactor = Math.sin(breathPhase * Math.PI * 2);

            const rotRad = ((organismRotation + continuousRotation) * Math.PI) / 180;
            const cosR = Math.cos(rotRad);
            const sinR = Math.sin(rotRad);

            // Reduce distortion as chaos decreases (more structured at bottom)
            const squeezePhase1 = (time % 12000) / 12000;
            const squeezePhase2 = (time % 8000) / 8000;
            const squeezePhase3 = (time % 19000) / 19000;
            const squeezeFactor = (Math.sin(squeezePhase1 * Math.PI * 2) * 0.6
                                + Math.sin(squeezePhase2 * Math.PI * 2) * 0.3
                                + Math.sin(squeezePhase3 * Math.PI * 2) * 0.25) * (0.3 + chaosFactor * 0.7);
            const initialSquash = Math.max(0, (1.5 - currentScale) * 1.2) * chaosFactor;
            const baseDistortion = 0.15 * chaosFactor;
            const scaleX = 1 + squeezeFactor * 0.35 + initialSquash + baseDistortion * Math.sin(squeezePhase2 * Math.PI * 4);
            const scaleY = 1 - squeezeFactor * 0.35 - initialSquash * 0.7 - baseDistortion * Math.sin(squeezePhase3 * Math.PI * 4);

            const rotationHueShift = Math.sin(continuousRotation * 0.01) * 25;

            // Update dot positions and opacity
            dots.forEach((dot, i) => {
                // Fade in dots from their birth time
                if (dot.birthTime !== null && dot.opacity < dot.targetOpacity) {
                    const fadeProgress = Math.min(1, (time - dot.birthTime) / 1500);
                    dot.opacity = fadeProgress * dot.targetOpacity;
                }

                dot.phase += 0.0025 + (i * 0.0004);

                // Wander decreases as chaos decreases (more stable at bottom)
                const wanderAmount = 0.3 + chaosFactor * 0.7;
                const wanderX = (Math.sin(dot.phase) * 45 + Math.sin(dot.phase * 1.7) * 25 + Math.sin(dot.phase * 0.3) * 18) * wanderAmount;
                const wanderY = (Math.cos(dot.phase * 0.7) * 45 + Math.cos(dot.phase * 1.3) * 25 + Math.cos(dot.phase * 0.5) * 18) * wanderAmount;

                // Interpolate between chaotic offset and structured flower position
                const chaoticOffset = chaoticOffsets[i] || { x: 0, y: 0 };
                const chaosX = chaoticOffset.x * chaosFactor * 1.5;
                const chaosY = chaoticOffset.y * chaosFactor * 1.5;

                const wanderHueShift = Math.sin(dot.phase * 0.5) * 18;
                dot.currentHue = dot.baseHue + rotationHueShift + wanderHueShift;
                dotElements[i].style.setProperty('--dot-hue', dot.currentHue);

                const breathExpand = breathFactor * 2;
                const breathScale = 1 + breathExpand * 0.01;

                // Add chaos offset to base position
                const baseWithChaos = {
                    x: dot.baseX + chaosX,
                    y: dot.baseY + chaosY
                };

                const expandedX = baseWithChaos.x * currentScale * scaleX * breathScale;
                const expandedY = baseWithChaos.y * currentScale * scaleY * breathScale;

                const rotatedX = expandedX * cosR - expandedY * sinR;
                const rotatedY = expandedX * sinR + expandedY * cosR;

                dot.x = organismX + rotatedX + wanderX;
                dot.y = organismY + rotatedY + wanderY;

                dotElements[i].setAttribute('cx', dot.x);
                dotElements[i].setAttribute('cy', dot.y);
                dotElements[i].style.opacity = dot.isCenter ? dot.opacity * 0.85 : dot.opacity;
            });

            // Update lines
            lineElements.forEach((lineData) => {
                const { element, from, to, birthTime } = lineData;
                const fromDot = dots[from];
                const toDot = dots[to];

                // Only draw if both dots are visible
                if (fromDot.opacity < 0.1 || toDot.opacity < 0.1) {
                    element.style.opacity = '0';
                    return;
                }

                // Fade in and grow new lines
                if (birthTime !== null) {
                    const lineAge = time - birthTime;
                    if (lineAge > 0) {
                        const fadeProgress = Math.min(1, lineAge / 1000);
                        lineData.opacity = fadeProgress * lineData.targetOpacity;
                        lineData.growProgress = Math.min(1, lineAge / lineGrowDuration);
                        lineData.growProgress = 1 - Math.pow(1 - lineData.growProgress, 3);
                    }
                } else if (lineData.stage === 0) {
                    // Initial lines grow from start
                    const thisLineDelay = 1300 + (lineData.index * lineStagger);
                    if (elapsed > thisLineDelay) {
                        lineData.growProgress = Math.min(1, (elapsed - thisLineDelay) / lineGrowDuration);
                        lineData.growProgress = 1 - Math.pow(1 - lineData.growProgress, 3);
                        lineData.opacity = 0.6;
                    }
                }

                const lineHue = (fromDot.currentHue + toDot.currentHue) / 2;
                element.style.setProperty('--line-hue', lineHue);

                element.setAttribute('x1', fromDot.x);
                element.setAttribute('y1', fromDot.y);
                element.setAttribute('x2', fromDot.x + (toDot.x - fromDot.x) * lineData.growProgress);
                element.setAttribute('y2', fromDot.y + (toDot.y - fromDot.y) * lineData.growProgress);
                element.style.opacity = lineData.opacity;
            });

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    })();

    // ==================== MOBILE VERSION ====================
    // Same behavior as desktop - absolute positioned, scroll-linked movement
    (function() {
        // Only run on mobile
        if (window.innerWidth > 768) return;

        const mobileSvg = document.getElementById('connected-dots-mobile-svg');
        const mobileContainer = document.getElementById('connected-dots-mobile-container');
        if (!mobileSvg || !mobileContainer) return;

        // Configuration
        const dotRadius = 4;
        const breathCycle = 10000;
        const lineGrowDuration = 3000;
        const lineGrowDelay = 1000;
        const lineStagger = 250;

        // Smaller hexagon for mobile (scaled down from desktop)
        const basePositions = [
            { x: 0, y: -70 },      // 0: top
            { x: 60, y: -35 },     // 1: top right
            { x: 60, y: 35 },      // 2: bottom right
            { x: 0, y: 70 },       // 3: bottom
            { x: -60, y: 35 },     // 4: bottom left
            { x: -60, y: -35 },    // 5: top left
            { x: 0, y: 0, isCenter: true }  // 6: center
        ];

        const connections = [
            [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5],
            [0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]
        ];

        // State
        const dots = [];
        const dotElements = [];
        const lineElements = [];
        const startTime = performance.now();

        // Organism position in SVG viewBox coordinates
        // viewBox is 0-400 x, 0-600 y (maps to viewport)
        let organismX = 200;  // Centered horizontally
        let organismY = 300;  // Center of viewport
        let organismRotation = 0;
        let currentScale = 1.2;

        // Target position the organism drifts toward (in SVG coords)
        let targetX = 200;
        let targetY = 300;
        let targetRotation = 0;
        let targetScale = 1.2;

        // Section positions (will be calculated)
        let sections = [];
        let pageHeight = 3000;

        // Initialize dots with color gradient
        basePositions.forEach((pos, i) => {
            const baseHue = pos.isCenter ? 100 : 100 + (i / 6) * 90 - 45; // Same range as desktop

            const dot = {
                baseX: pos.x,
                baseY: pos.y,
                x: organismX + pos.x,
                y: organismY + pos.y,
                phase: Math.random() * Math.PI * 2,
                isCenter: pos.isCenter || false,
                baseHue: baseHue,
                currentHue: baseHue
            };
            dots.push(dot);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('class', 'dot');
            circle.setAttribute('r', dot.isCenter ? dotRadius * 1.3 : dotRadius);
            if (dot.isCenter) circle.style.opacity = '0.85';
            circle.setAttribute('cx', dot.x);
            circle.setAttribute('cy', dot.y);
            circle.style.setProperty('--dot-hue', baseHue);
            dotElements.push(circle);
        });

        // Initialize lines
        connections.forEach(([i, j], idx) => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('class', 'line');
            line.setAttribute('x1', dots[i].x);
            line.setAttribute('y1', dots[i].y);
            line.setAttribute('x2', dots[i].x);
            line.setAttribute('y2', dots[i].y);
            const lineHue = (dots[i].baseHue + dots[j].baseHue) / 2;
            line.style.setProperty('--line-hue', lineHue);
            lineElements.push({ element: line, from: i, to: j, index: idx });
            mobileSvg.appendChild(line);
        });
        dotElements.forEach(el => mobileSvg.appendChild(el));

        // Scroll-based movement - directly set position (no lerp delay)
        function handleScroll() {
            const scrollY = window.scrollY;
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            const scrollProgress = Math.min(1, Math.max(0, scrollY / maxScroll));

            // DIRECTLY set organism position based on scroll
            // X: swing between left (80) and right (320)
            organismX = 200 + Math.sin(scrollProgress * Math.PI * 3) * 120;
            // Y: move up and down in viewport
            organismY = 200 + Math.sin(scrollProgress * Math.PI * 2) * 150;
            // Also update targets for lerp (rotation/scale still use lerp)
            targetRotation = scrollProgress * 180;
            targetScale = 1.0 + scrollProgress * 0.5;
        }

        window.addEventListener('scroll', handleScroll, { passive: true });
        // Set initial position
        handleScroll();

        let continuousRotation = 0;

        function animate(time) {
            const elapsed = time - startTime;

            // Position is set directly by handleScroll, just lerp rotation/scale
            const lerpSpeed = 0.08;
            organismRotation += (targetRotation - organismRotation) * lerpSpeed;
            currentScale += (targetScale - currentScale) * lerpSpeed;

            continuousRotation += 0.015;

            const breathPhase = (time % breathCycle) / breathCycle;
            const breathFactor = Math.sin(breathPhase * Math.PI * 2);

            const rotRad = ((organismRotation + continuousRotation) * Math.PI) / 180;
            const cosR = Math.cos(rotRad);
            const sinR = Math.sin(rotRad);

            // Squeeze/stretch - organic distortion (no initial squash on mobile)
            const squeezePhase1 = (time % 12000) / 12000;
            const squeezePhase2 = (time % 8000) / 8000;
            const squeezePhase3 = (time % 19000) / 19000;
            const squeezeFactor = Math.sin(squeezePhase1 * Math.PI * 2) * 0.5
                                + Math.sin(squeezePhase2 * Math.PI * 2) * 0.25
                                + Math.sin(squeezePhase3 * Math.PI * 2) * 0.2;
            const baseDistortion = 0.12;
            const scaleX = 1 + squeezeFactor * 0.3 + baseDistortion * Math.sin(squeezePhase2 * Math.PI * 4);
            const scaleY = 1 - squeezeFactor * 0.3 - baseDistortion * Math.sin(squeezePhase3 * Math.PI * 4);

            // Color shift based on movement and rotation
            const rotationHueShift = Math.sin(continuousRotation * 0.01) * 25;

            dots.forEach((dot, i) => {
                // Large wander for overlapping dots (scaled for mobile)
                dot.phase += 0.0025 + (i * 0.0006);
                const wanderX = Math.sin(dot.phase) * 30 + Math.sin(dot.phase * 1.7) * 18 + Math.sin(dot.phase * 0.3) * 12;
                const wanderY = Math.cos(dot.phase * 0.7) * 30 + Math.cos(dot.phase * 1.3) * 18 + Math.cos(dot.phase * 0.5) * 12;

                // Dynamic hue shift
                const wanderHueShift = Math.sin(dot.phase * 0.5) * 18;
                dot.currentHue = dot.baseHue + rotationHueShift + wanderHueShift;
                dotElements[i].style.setProperty('--dot-hue', dot.currentHue);

                const breathExpand = breathFactor * 2;
                const breathScale = 1 + breathExpand * 0.01;

                const expandedX = dot.baseX * currentScale * scaleX * breathScale;
                const expandedY = dot.baseY * currentScale * scaleY * breathScale;

                const rotatedX = expandedX * cosR - expandedY * sinR;
                const rotatedY = expandedX * sinR + expandedY * cosR;

                dot.x = organismX + rotatedX + wanderX;
                dot.y = organismY + rotatedY + wanderY;

                dotElements[i].setAttribute('cx', dot.x);
                dotElements[i].setAttribute('cy', dot.y);
            });

            lineElements.forEach(({ element, from, to, index }) => {
                const fromDot = dots[from];
                const toDot = dots[to];

                // Update line hue dynamically
                const lineHue = (fromDot.currentHue + toDot.currentHue) / 2;
                element.style.setProperty('--line-hue', lineHue);

                const thisLineDelay = lineGrowDelay + (index * lineStagger);
                let growProgress = elapsed > thisLineDelay ? Math.min(1, (elapsed - thisLineDelay) / lineGrowDuration) : 0;
                growProgress = 1 - Math.pow(1 - growProgress, 3);

                element.setAttribute('x1', fromDot.x);
                element.setAttribute('y1', fromDot.y);
                element.setAttribute('x2', fromDot.x + (toDot.x - fromDot.x) * growProgress);
                element.setAttribute('y2', fromDot.y + (toDot.y - fromDot.y) * growProgress);
            });

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    })();
    </script>

</body>
</html>
